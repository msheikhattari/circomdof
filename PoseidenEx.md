```
template PoseidonEx(nInputs, nOuts) {
    signal input inputs[nInputs]; \\s=nInputs
    signal input initialState; \\s=nInputs+1 
    signal output out[nOuts]; \\s=nInputs+1 + nOuts

    // Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
    // Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
    // And rounded up to nearest integer that divides by t
    var N_ROUNDS_P[16] = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68];
    var t = nInputs + 1;
    var nRoundsF = 8;
    var nRoundsP = N_ROUNDS_P[t - 2];
    var C[t*nRoundsF + nRoundsP] = POSEIDON_C(t);
    var S[  N_ROUNDS_P[t-2]  *  (t*2-1)  ]  = POSEIDON_S(t);
    var M[t][t] = POSEIDON_M(t);
    var P[t][t] = POSEIDON_P(t);

    component ark[nRoundsF]; \\component
    component sigmaF[nRoundsF][t]; \\component
    component sigmaP[nRoundsP]; \\component
    component mix[nRoundsF-1]; \\component
    component mixS[nRoundsP]; \\component
    component mixLast[nOuts]; \\component


    ark[0] = Ark(t, C, 0); \\component
    for (var j=0; j<t; j++) {
        if (j>0) {
            ark[0].in[j] <== inputs[j-1]; 
        } else {
            ark[0].in[j] <== initialState;
        }
    }
    \\c=nInputs+1

    for (var r = 0; r < nRoundsF\2-1; r++) {
        for (var j=0; j<t; j++) {
            sigmaF[r][j] = Sigma();
            if(r==0) {
                sigmaF[r][j].in <== ark[0].out[j];
            } else {
                sigmaF[r][j].in <== mix[r-1].out[j];
            }
        }
	\\c=nInputs+1+3*(nInputs + 1)

        ark[r+1] = Ark(t, C, (r+1)*t); \\component
        for (var j=0; j<t; j++) {
            ark[r+1].in[j] <== sigmaF[r][j].out;
        } \\c=5*(nInputs + 1)

        mix[r] = Mix(t,M); \\component
        for (var j=0; j<t; j++) {
            mix[r].in[j] <== ark[r+1].out[j];
        }
        \\c=6*(nInputs + 1)

    }

    for (var j=0; j<t; j++) {
        sigmaF[nRoundsF\2-1][j] = Sigma();
        sigmaF[nRoundsF\2-1][j].in <== mix[nRoundsF\2-2].out[j];
    }
    \\c=7*(nInputs + 1)

    ark[nRoundsF\2] = Ark(t, C, (nRoundsF\2)*t ); \\component
    for (var j=0; j<t; j++) {
        ark[nRoundsF\2].in[j] <== sigmaF[nRoundsF\2-1][j].out;
    }
    \\c=8*(nInputs + 1)

    mix[nRoundsF\2-1] = Mix(t,P); \\component
    for (var j=0; j<t; j++) {
        mix[nRoundsF\2-1].in[j] <== ark[nRoundsF\2].out[j];
    }
    \\c=9*(nInputs + 1)


    for (var r = 0; r < nRoundsP; r++) {
        sigmaP[r] = Sigma(); \\component
        if (r==0) {
            sigmaP[r].in <== mix[nRoundsF\2-1].out[0];
        } else {
            sigmaP[r].in <== mixS[r-1].out[0];
        }
    \\ c= 9*(nInputs + 1) + N_ROUNDS_P[nInputs - 1]

        mixS[r] = MixS(t, S, r); \\component
        for (var j=0; j<t; j++) {
            if (j==0) {
                mixS[r].in[j] <== sigmaP[r].out + C[(nRoundsF\2+1)*t + r];
            } else {
                if (r==0) {
                    mixS[r].in[j] <== mix[nRoundsF\2-1].out[j];
                } else {
                    mixS[r].in[j] <== mixS[r-1].out[j];
                }
            }
        }
        \\ c= 10*(nInputs + 1) + N_ROUNDS_P[nInputs - 1]
    }

    for (var r = 0; r < nRoundsF\2-1; r++) {
        for (var j=0; j<t; j++) {
            sigmaF[nRoundsF\2 + r][j] = Sigma(); \\component
            if (r==0) {
                sigmaF[nRoundsF\2 + r][j].in <== mixS[nRoundsP-1].out[j];
            } else {
                sigmaF[nRoundsF\2 + r][j].in <== mix[nRoundsF\2+r-1].out[j];
            }
        }
	c= 13*(nInputs + 1) + N_ROUNDS_P[nInputs - 1]

        ark[ nRoundsF\2 + r + 1] = Ark(t, C,  (nRoundsF\2+1)*t + nRoundsP + r*t ); \\component
        for (var j=0; j<t; j++) {
            ark[nRoundsF\2 + r + 1].in[j] <== sigmaF[nRoundsF\2 + r][j].out;
        }
        c= 14*(nInputs + 1) + N_ROUNDS_P[nInputs - 1]

        mix[nRoundsF\2 + r] = Mix(t,M); \\component
        for (var j=0; j<t; j++) {
            mix[nRoundsF\2 + r].in[j] <== ark[nRoundsF\2 + r + 1].out[j];
        }
        c= 15*(nInputs + 1) + N_ROUNDS_P[nInputs - 1]

    }

    for (var j=0; j<t; j++) {
        sigmaF[nRoundsF-1][j] = Sigma(); \\component
        sigmaF[nRoundsF-1][j].in <== mix[nRoundsF-2].out[j];
    }
    c= 16*(nInputs + 1) + N_ROUNDS_P[nInputs - 1]

    for (var i=0; i<nOuts; i++) {
        mixLast[i] = MixLast(t,M,i); \\component
        for (var j=0; j<t; j++) {
            mixLast[i].in[j] <== sigmaF[nRoundsF-1][j].out;
        }
        out[i] <== mixLast[i].out;
    }
    c= 9*(nInputs + 1) + N_ROUNDS_P[nInputs - 1] + nOuts*(nInputs + 2)

}
```
nInputs + 1 + nOuts signals, `(9 + nOuts)*nInputs + 2*nOuts + N_ROUNDS_P[nInputs - 1] + 9` constraints. The dof of [[Ark]] is nInputs + 1 (called 8 times). The dof of [[Sigma]] is 1 (called `8(nInputs + 1) + N_ROUNDS_P[nInputs - 1]` times). The dof of [[Mix]] is nInputs + 1 (called 7 times). The dof of [[MixS]] is nInputs + 1 (called `N_ROUNDS_P[nInputs - 1]` times). The dof of [[MixLast]] is nInputs + 1 (called nOuts times). In total: `nInputs + 1 + nOuts - ((9 + nOuts)*nInputs + 2*nOuts + N_ROUNDS_P[nInputs - 1] + 9) + 8(nInputs + 1) + 8(nInputs+1) + N_ROUNDS_P[nInputs - 1] + 7(nInputs+1) + (nInputs + 1)N_ROUNDS_P[nInputs - 1] + (nInputs + 1)nOuts = nInputs(2nOuts + 15 + N_ROUNDS_P[nInputs - 1]) + 5 + N_ROUNDS_P[nInputs - 1]

`dof = nInputs(2nOuts + 15 + N_ROUNDS_P[nInputs - 1]) + 5 + N_ROUNDS_P[nInputs - 1]`

